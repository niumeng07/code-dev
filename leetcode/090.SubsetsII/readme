Given a collection of integers that might contain duplicates, nums, return all possible subsets.

Note: The solution set must not contain duplicate subsets.

For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
code result
[ 2, ]
[ 1, ]
[ 1, 2, 2, ]
[ 2, 2, ]
[ 1, 2, ]

从以上的示例中看到subsets是有序的, 即在[2,1]不是[1,2,2]的subset
问题:
[1,2,3]中[1,3]是否算subsets?

解题思路, 搜索
从第一个字符开始,记i
    选取第j=i个字符，放入vector tmp
    tmp放入reult
    如果j 不为end，对j+1做该处理
    i++

伪码
dfs(vector<int> &tmp, vector<int> &nums, int start)
    tmp.push(nums[start])
    result.push_back(tmp)
    if(start != nums.end() )
        dfs(tmp, nums, start + 1)
    else
        tmp.pop
        return
