Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.

For example:

Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].

Note:
The order of the result is not important. So in the above example, [5, 3] is also correct.
Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?

最简单的思路是建一个Map
    时间复杂度O(n)
    空间复杂度O(n)
但本题要求，有O(n)复杂度且O(1)空间复杂度
    相同得0,不同得原值
    3XOR5->011XOR101=110
思路：
    step:1  
      所有值异或，相同的值必然得到0，
      最后结果必然是两个不同的值的异或的结果，即对上面的例子，异或后的结果是3和5异或的结果(A,B)
    step:2 
      怎样区分开这两个值呢？
      这两个值转化为二进制后，必然在某一位上不同
      把整个数据根据这一位是0还是1分成两个数组,A/B一定在两个数组中，
      而任务两个相同的值一定在一个数组中，在分别从两个数组中求一次异或
这个题是不是还可以扩展为如果有三个单独的数字，其它都是出现两次的数字
