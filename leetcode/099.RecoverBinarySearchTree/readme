Two elements of a binary search tree (BST) are swapped by mistake.

Recover the tree without changing its structure.

Note:
A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?

          5
    2           7
  1   3       6  8
        4
中序: 1 2 3 4 5 6 7 8
交换3 4: 变成1 2 4 3 5 6 7 8  //[3 4]一个逆序
交换4 6: 变成1 2 3 6 5 4 7 8  //[6 5] [6 4] [5 4]三个逆序
交换4 5: 变成1 2 3 5 4 6 7 8  //[5 4]逆序
          4
    2           7
  1   3       6  8
        5
交换1 8: 变成8 2 3 4 5 6 7 1  //[8 2] [8 3] ... [8 1] [2 1] ... [7 1]
          5
    2           7
  8   3       6  1
        4

交换逆序的最后一个数和第一个数
从第一个数开始遍历，如果是逆序数之一，保存，找到第一个和最后一个，交换

问题是怎样恢复原来的结构
--中序遍历形成vector时，vector不直接存储值，而是存储指针
